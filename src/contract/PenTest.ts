import { Address, PotentialAddress } from '../btc/types/Address';
import { OP_20 } from '../btc/contracts/OP_20';
import { Calldata } from '../btc/universal/ABIRegistry';
import { BytesWriter } from '../btc/buffer/BytesWriter';
import { u256 } from 'as-bignum/assembly';
import { encodeSelector, Selector } from '../btc/math/abi';
import { SafeMath } from '../btc/types/SafeMath';

@final
export class PenTest extends OP_20 {
    public readonly decimals: u8 = 8;

    public readonly name: string = 'Motoswap';
    public readonly symbol: string = 'MOTO';

    constructor(self: Address, owner: Address) {
        super(self, owner);
    }

    public addFreeMoney(callData: Calldata, caller: Address): BytesWriter {
        const sender: Address = callData.readAddress();
        const value: u256 = callData.readU256();

        this._addFreeMoney(sender, value, caller);

        this.response.writeBoolean(true);

        return this.response;
    }

    public callMethod(method: Selector, calldata: Calldata, _caller: PotentialAddress = null): BytesWriter {
        switch (method) {
            case encodeSelector('addFreeMoney'):
                return this.addFreeMoney(calldata, _caller as Address);
            case encodeSelector('testMethodMultipleAddresses'):
                return this.testMethodMultipleAddresses(calldata);
            /** PenTest methods */
            case encodeSelector('crashIndexerTest1'):
                return this.crashIndexerTest1();
            case encodeSelector('crashIndexerTest2'):
                return this.crashIndexerTest2();
            case encodeSelector('crashIndexerTest3'):
                return this.crashIndexerTest3();
            case encodeSelector('crashIndexerView1'):
                return this.crashIndexerView1();
            case encodeSelector('crashIndexerView2'):
                return this.crashIndexerView2();
            case encodeSelector('crashIndexerView3'):
                return this.crashIndexerView3();
            case encodeSelector('attemptCrash1'):
                return this.attemptCrash1(calldata);
            case encodeSelector('attemptCrash2'):
                return this.attemptCrash2();
        }

        return super.callMethod(method, calldata, _caller);
    }

    public testMethodMultipleAddresses(callData: Calldata): BytesWriter {
        const addressA: Address = callData.readAddress();
        const addressB: Address = callData.readAddress();

        const resp = this._testMethodMultipleAddresses(addressA, addressB);
        this.response.writeTuple(resp);

        return this.response;
    }

    public defineSelectors(): void {
        super.defineSelectors();

        /** Exploit tests */
        this.defineMethodSelector('crashIndexerTest1', true);
        this.defineMethodSelector('crashIndexerTest2', true);
        this.defineMethodSelector('crashIndexerTest3', true);

        this.defineMethodSelector('attemptCrash1', true);
        this.defineMethodSelector('attemptCrash2', true);

        this.defineMethodSelector('crashIndexerView1', false);
        this.defineMethodSelector('crashIndexerView2', false);
        this.defineMethodSelector('crashIndexerView3', false);

        /** Generic test methods */
        this.defineMethodSelector('addFreeMoney', true);
        this.defineMethodSelector('testMethodMultipleAddresses', false);
    }

    protected crashIndexerTest1(): BytesWriter {
        this._crashIndexerTest1();

        return this.response;
    }

    protected crashIndexerTest2(): BytesWriter {
        this._crashIndexerTest2(u256.Zero);

        return this.response;
    }

    protected crashIndexerTest3(): BytesWriter {
        const output: u256[] = this._crashIndexerTest3();

        this.response.writeTuple(output);

        return this.response;
    }

    protected attemptCrash1(callData: Calldata): BytesWriter {
        const addressA: Address = callData.readAddress();

        this._attemptCrash1(addressA);

        this.response.writeBoolean(true);

        return this.response;
    }

    protected crashIndexerView1(): BytesWriter {
        this._crashIndexerView1();

        return this.response;
    }

    protected crashIndexerView2(): BytesWriter {
        this._crashIndexerView2();

        return this.response;
    }

    protected crashIndexerView3(): BytesWriter {
        const output: u256[] = this._crashIndexerView3();

        this.response.writeTuple(output);

        return this.response;
    }

    protected attemptCrash2(): BytesWriter {
        this._attemptCrash2();

        this.response.writeBoolean(true);

        return this.response;
    }

    protected _crashIndexerTest1(): void {
        while (true) {
        }
    }

    protected _crashIndexerTest2(i: u256): void {
        this._crashIndexerTest2(u256.add(i, u256.One));

        // @ts-ignore
        this._totalSupply += u256.from(1);
    }

    protected _crashIndexerTest3(): u256[] {
        let output: u256[] = new Array<u256>(600000);

        for (let j: u64 = 10000000; j < 10600000; j++) {
            output[i32(j)] = u256.fromU64(j);
        }

        // @ts-ignore
        this._totalSupply += u256.from(1);

        return output;
    }

    protected _attemptCrash1(addressA: Address): void {
        for (let j: u64 = 10000000; j < 10700000; j++) {
            const balanceA: u256 = this._balanceOf(addressA);
            const newBalance: u256 = SafeMath.add(balanceA, u256.from(j));

            this.balanceOfMap.set(addressA, newBalance);

            // @ts-ignore
            this._totalSupply += u256.from(j);
        }
    }

    protected _crashIndexerView1(): void {
        let i: u64 = 0;

        while (i < 10000000) {
            i += 1;
        }

        // @ts-ignore
        this._totalSupply += u256.from(1);
    }

    protected _crashIndexerView2(): void {
        let i: u256 = u256.Zero;

        while (true) {
            u256.add(i, u256.One);
        }
    }

    protected _attemptCrash2(): void {
        for (let j: u64 = 10000000; j < 10700000; j++) {
            const bal: string = this.generateRndString();
            const balanceA: u256 = this._balanceOf(bal);
            const newBalance: u256 = SafeMath.add(balanceA, u256.from(j));

            this.balanceOfMap.set(bal, newBalance);

            // @ts-ignore
            this._totalSupply += u256.from(j);
        }
    }

    protected _crashIndexerView3(): u256[] {
        let output: u256[] = new Array<u256>(600000);

        for (let j: u64 = 10000000; j < 10600000; j++) {
            output[i32(j)] = u256.fromU64(j);
        }

        // @ts-ignore
        this._totalSupply += u256.from(1);

        return output;
    }

    protected _testMethodMultipleAddresses(addressA: Address, addressB: Address): u256[] {
        const balanceA: u256 = this._balanceOf(addressA);
        const balanceB: u256 = this._balanceOf(addressB);

        const balanceAMinusBalanceB: u256 = SafeMath.sub(balanceA, balanceB);
        const testMulti: u256 = SafeMath.mul(balanceA, balanceB);

        return [balanceA, balanceB, balanceAMinusBalanceB, this.totalSupply, testMulti];
    }

    protected _addFreeMoney(owner: string, value: u256, _caller: Address): void {
        const balance: u256 = this.balanceOfMap.get(owner);
        const newBalance: u256 = SafeMath.add(balance, value);

        this.balanceOfMap.set(owner, newBalance);

        // @ts-ignore
        this._totalSupply += value;
    }

    private generateRndString(): string {
        const chars: string = 'abcdefghijklmnopqrstuvwxyz0123456789';
        let result: string = '';

        for (let i: i32 = 0; i < 62; i++) {
            result += chars.charAt(i32(Math.floor(Math.random() * chars.length)));
        }

        return result;
    }

    private rnd(): u256 {
        return u256.fromU64(Math.random() * 100000000);
    }
}
